% !TeX root = ../../main.tex
\subsection{Voronoi Diagrams Extended}%
\label{sec:eval.voronoi}

In the previous section, we left the problem of Voronoi Diagrams partially
unresolved.  This section expands on it by repurposing \ac{CGAL}'s version of
the Voronoi Diagram algorithm~\cite{CGAL:5.3:VDA2} and comparing it with a
native Julia implementation of the algorithm described
in~\cite{Springel:2010:GCHSMM}, provided by the
\texttt{VoronoiDelaunay.jl}\footnote{\url{https://github.com/JuliaGeometry/VoronoiDelaunay.jl}}
package.  We estimate the effort required to obtain either implementation,
measuring Delaunay Triangulation construction performance, and compare the
outputs of both algorithms.

Wrapping \ac{CGAL}'s Voronoi diagram algorithm follows a similar process to that
used by our solution's \wrapper{} component.  Requiring bare minimal C++
knowledge and following reference documentation as if it were a recipe book, it
may take no more than a full day to obtain the necessary functionality.

The algorithm present in \texttt{VoronoiDelaunay.jl} is the result of an immense
body of research~\cite{Springel:2010:GCHSMM}.  It is safe to say that it took
more than a full day to obtain a robust implementation, requiring interpretation
and understanding of the approach described in the~\cite{Springel:2010:GCHSMM}
since there is no explicit algorithm listed.

Regarding both algorithms' performance, \cref{fig:eval.voronoi.bench} shows
the results of building Delaunay Triangulations by batch inserting several
powers-of-ten sets of points.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}
  \begin{loglogaxis}[ybar=0pt,
    title={\texttt{CGAL.jl} vs.\ \texttt{VoronoiDelaunay.jl}},
    xlabel={Number of Points (log)},
    ylabel={Average Time (ns, log)},
    width={\linewidth},
    height=5cm,
    bar width=3.16227766,% 10^(1/n) where n = 2 (bars)
    enlarge y limits={.25,upper},
    enlarge x limits={abs=3.16227766},
    legend columns=-1,
    table/col sep=comma,
  ]
    \addplot+ table {data/voronoi-vdjl.csv};
    \addplot+ table {data/voronoi-cgal.csv};
    \legend{VoronoiDelaunay.jl,CGAL.jl}
  \end{loglogaxis}
  \end{tikzpicture}
  \caption{\label{fig:eval.voronoi.bench}
    Delaunay Triangulation benchmark results.}%
\end{figure}

Results are pretty identical.  However, we see \ac{CGAL}'s variant of the
algorithm beating \texttt{VoronoiDelaunay.jl}'s by a relatively small margin.

Finally, we take a look at the output meshes produced by both implementations,
illustrated in \cref{fig:eval.voronoi.output}.

\begin{figure}[htb]
  \resizebox{\linewidth}{!}{\input{tikz/voronoi-plots.tikz}}
  \caption{\label{fig:eval.voronoi.output}
    Delaunay Triangulations (on the left) and Voronoi Diagrams (on the right)
    produced both by \texttt{CGAL.jl} and \texttt{VoronoiDelaunay.jl}.}%
\end{figure}

Surprisingly, the triangulations are not the same, explaining the divergence in
the respective Voronoi Diagrams.  Simpler point distributions illustrate this
disparity further.  Though it is not clear which of the implementations is
wrong, given \ac{CGAL} is a more mature library, it is probably safe to assume
that the implementation in \texttt{VoronoiDelaunay.jl} is the culprit.

Summarily, new implementations of complex algorithms from scratch are very
likely to produce erroneous results, paling in comparison to more mature
alternatives that may be repurposed.  Despite showing potential, new
implementations will have a hard time competing with established battle-tested
software.
