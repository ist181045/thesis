% !TeX root = ../../main.tex
\subsection{Voronoi Diagrams Extended}%
\label{sec:eval.voronoi}

In the previous section, we left the problem of Voronoi Diagrams partially
unresolved.  This section expands on it, repurposing \ac{CGAL}'s version of the
Voronoi Diagram algorithm~\cite{CGAL:5.3:VDA2} and comparing it with a native
Julia implementation of the algorithm described in~\cite{Springel:2010:GCHSMM}
available in the
\texttt{VoronoiDelaunay.jl}\footnote{\url{https://github.com/JuliaGeometry/VoronoiDelaunay.jl}}
package.  We estimate the effort required to obtain either implementation,
measuring Delaunay Triangulation construction performance, and compare the
outputs of both algorithms.

Wrapping \ac{CGAL}'s Voronoi diagram algorithm follows a similar process to that
used by our solution's \wrapper{} component.  Requiring bare minimal C++
knowledge and following reference documentation as if it were a recipe book, it
may take no more than a full day to obtain the necessary functionality.

The algorithm present in \texttt{VoronoiDelaunay.jl} is the result of an immense
body of research~\cite{Springel:2010:GCHSMM}.  It is safe to say that it took
more than a full day to obtain a robust implementation, requiring interpretation
and understanding of the approach described in the~\cite{Springel:2010:GCHSMM}
since there is no explicit algorithm listed.

Regarding both algorithms' performance, \cref{fig:eval.voronoi.bench} shows
the results of building Delaunay Triangulations by batch inserting several
powers-of-ten sets of points.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}
  \begin{loglogaxis}[ybar=0pt,
    title={\texttt{CGAL.jl} vs.\ \texttt{VoronoiDelaunay.jl}},
    xlabel={Number of Points (log)},
    ylabel={Average Time (ns, log)},
    width={\linewidth},
    height=6cm,
    bar width=3.16227766,% 10^(1/n) where n = 2 (bars)
    enlarge y limits={.2,upper},
    enlarge x limits={abs=3.16227766},
    legend columns=-1,
    table/col sep=comma,
    error bars/y explicit,
    error bars/y dir=both
  ]
    \addplot+ table [y error index=2] {data/voronoi-vdjl.csv};
    \addplot+ table [y error index=2] {data/voronoi-cgal.csv};
    \legend{VoronoiDelaunay.jl,CGAL.jl}
  \end{loglogaxis}
  \end{tikzpicture}
  \caption{\label{fig:eval.voronoi.bench}
    Delaunay Triangulation benchmark results.}%
\end{figure}

Results are pretty identical.  However, we see \ac{CGAL}'s variant of the
algorithm beating \texttt{VoronoiDelaunay.jl}'s by a relatively small margin.

Finally, we take a look at the output Delaunay Triangulations and their
respective Voronoi Diagrams, produced by both implementations.
\Cref{fig:eval.voronoi.output} illustrates two plots of the output meshes: on
the left, the Delaunay Triangulations, and on the right, the respective dual
Voronoi Diagrams.

\begin{figure}[htb]
  \resizebox{\linewidth}{!}{\input{tikz/voronoi-plots.tikz}}
  \caption{\label{fig:eval.voronoi.output}
    Delaunay Triangulations (on the left) and Voronoi Diagrams (on the right)
    produced both by \texttt{CGAL.jl} and \texttt{VoronoiDelaunay.jl}.}%
\end{figure}

Surprisingly, the triangulations are not the same, explaining the divergence in
the respective Voronoi Diagrams.  Simpler point distributions illustrate this
disparity further.  \Cref{fig:eval.voronoi.surprising} shows this scenario
blatantly.

\begin{figure}[htb]
  \resizebox{\linewidth}{!}{\input{tikz/voronoi-surprising.tikz}}
  \caption[Surprising Voronoi Delaunay output]{
    \ac{CGAL}'s algorithm produced a triangle (on the left) while
    \texttt{VoronoiDelaunay.jl} did not.  Consequently, \ac{CGAL} did not
    produce a (finite) Voronoi Diagram while \texttt{VoronoiDelaunay.jl} did (on
    the right).}%
  \label{fig:eval.voronoi.surprising}
\end{figure}

It is not clear which of the implementations is wrong.  Though, given that
\ac{CGAL} is a more mature library, it is probably safe to assume that the
implementation in \texttt{VoronoiDelaunay.jl} has issues.

Summarily, re-implementations of complex algorithms from scratch are very likely
to produce erroneous results, paling in comparison to more mature alternatives
that may be repurposed.  Though new implementations may show potential, it will
be hard to compete with established battle-tested software.
