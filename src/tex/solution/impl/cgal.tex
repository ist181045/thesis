\subsection{Computational Geometry Algorithms Library}%
\label{sec:solution.impl.cgal}

\Ac{CGAL} is a software project that provides easy access to efficient and
reliable geometric algorithms in the form of a C++
library~\cite{CGAL:5.3:Project}.  It offers a multitude of data structures and
algorithms, such as triangulations, Voronoi diagrams, and convex hull
algorithms, to name a few.  The library is broken up into three
parts~\cite{CGAL:5.3:23LGK}:
\begin{enumerate}
  \item The kernel, which consists of geometric primitive objects and operations
  on these objects.  The objects are represented both as
  \begin{enumerate*}
    \item stand-alone classes parameterized by a representation class that
    specifies the underlying number types used for computation, and as
    \item members of the kernel classes, which allows for more flexibility and
    adaptability of the kernel;
  \end{enumerate*}
  \item Basic geometric data structures and algorithms, parameterized by traits
  classes that define the interface between the data structure or algorithm and
  the primitives they use;
  \item Non-geometric support facilities, such as circulators, random sources,
  and I/O support for debugging and for interfacing \ac{CGAL} to various
  visualization tools.
\end{enumerate}

\Cref{lst:solution.impl.cgal.pas} showcases an example of a very simple
\ac{CGAL} program, demonstrating the construction of some points and a segment,
and performing some basic operations on them.

\begin{listing}[htbp]
  \caption[CGAL: Three points and one segment]{
    An example CGAL program illustrating how to construct some points and a line
    segment, and perform some basic operations on them.  It uses
    \mintinline{c}{double} precision floating point numbers for Cartesian
    coordinates.}\label{lst:solution.impl.cgal.pas}
  \inputminted{cpp}{cpp/points_and_segments.cpp}
\end{listing}

As mentioned, geometric primitive types are defined in the kernel.  The chosen
kernel in the example uses \texttt{double} precision floating point numbers for
the Cartesian coordinates of the point.

We can also see some predicates, such as testing the orientation of three
points, and constructions, like the distance\footnote{It is worth noting
\ac{CGAL} does \texttt{not} compute the absolute distance, offering instead to
compute the squared distance, avoiding the additional square root computation.
This preserves exactness and avoids a potentially unnecessary heavy
computation.} and midpoint computation.  Predicates typically produce a boolean
logical value or one of a discrete set of possible results, whereas
constructions produce either a number or another geometric entity.

It is worth noting that floating point-based geometric computation can lead to
surprising results since we are relying on inexact constructions.  If one must
ensure that the numbers get interpreted at their full precision, \ac{CGAL}
offers kernels that perform exact predicates and exact constructions.
Revisiting \cref{lst:solution.impl.cgal.pas}, it is as simple as switching the
\texttt{Simple\_cartesian} kernel with one the provides exact constructions,
e.g., \texttt{Exact\_predicates\_exact\_constructions\_kernel} or \texttt{Epeck}
for short.

\ac{CGAL} is arguably considered as the industry's \textit{de facto} geometric
library, used in well-known projects such as
OpenSCAD~\cite{Kintel:2019:OpenSCAD}.  It is a very mature software library with
decades of Ph.D.-grade research results, still being actively maintained to this
day.  Being an Open Source project, one can easily contribute to it by reporting
issues or bugs in the software as well as directly submitting
patches.\footnote{The library's source is hosted on GitHub at
\url{https://github.com/CGAL/cgal}.  To illustrate the ease with which one can
contribute, here is a pull request the author submitted:
\url{https://github.com/CGAL/cgal/pull/4705}.}

These factors, among others, justify our choice for our solution's \textit{Exact
Computation Geometric Library} component.  We chose \ac{CGAL} because of its
comprehensiveness and decades of work instead of relying on less mature
software, as well as the critical mass of maintainers behind it.  That is not to
say less mature software cannot be used in its stead, though it is unlikely they
can match \ac{CGAL}, be it in terms of performance, quality, or breadth.

However, \ac{CGAL} is a terribly complex library under the hood, presenting many
challenges when it comes to mapping it to the Julia language.  Firstly, it is
a C++ library.  Despite Julia's native capabilities for interoperating with C,
there's additional work to be done to reach C++ code.  Secondly, a partial
problem also shared by C, is memory management, which differs between C/C++ and
Julia, potentially leading to memory leaks and other related issues if not
properly tended to.  Finally, \ac{CGAL} makes extensive use of C++ templates,
proving sometimes difficult to transparently map some of its constructs.

Fortunately, there are both methods and additional libraries that aid us by
transparently overcoming some of those issues.  In the next section, we go over
how we overcame these issues, demonstrating it by reproducing the example in
\cref{lst:solution.impl.cgal.pas} in Julia.
