% !TEX root = ../../main.tex
\section{Implementation}%
\label{sec:solution.impl}

This section details implementation choices with regard to the chosen platforms
for realizing the initially proposed general solution architecture, previously
illustrated in \cref{fig:solution.arch}. Following a brief analysis, we expand
specifically on the concrete components corresponding to the ones within the
light blue rectangle.

Examining the \ac{AD} workflow portion of \cref{fig:solution.arch}, there are
depictions of \ac{CAD}, \ac{BIM}, and analysis tools, of which examples could be
Rhinoceros3D, Autodesk's Revit, and Radiance, respectively, with no particular
focus on any of them.  Digging a layer deeper, we find the \ac{AD} tool, which,
by means made available by the tools above it, produces models specific to those
tools from a description provided by the user.  The \ac{AD} tool we've chosen
was Khepri~\cite{Leitao:2018:Khepri.jl,Leitao:2019:GRUGEAV}, a text-based tool
written in the Julia programming language~\cite{Bezanson:2017:JAFANC}.  Khepri
is the successor of another text-based \ac{AD} tool named
Rosetta~\cite{Leitao:2011:PGDCAD}, a tool written in the Racket programming
language~\cite{PLT:2010:Reference}.  It follows that the \textit{Geometric
Constraint Primitives} were implemented in the Julia language as well, supported
by an \textit{Exact Computation Geometry Library}.  The library chosen for the
effect was the \acf{CGAL}~\cite{CGAL:2018}, a highly performant and robust
geometric library written in the C++ programming
language~\cite{Stroustrup:2013:CPP}.

This language disparity between the \textit{Geometric Constraint Primitives}
module and the \textit{Exact Computation Geometry Library} requires a solution
for language interoperation.  In other words, we need to make \ac{CGAL}
available to the Julia language.  Fortunately, the Julia language already
possesses facilities that allow it to invoke functionality within libraries
written in the C~\cite{Kernighan:1988:C} or the
Fortran~\cite{Backus:1957:Fortran} programming languages.  This interfacing
mechanism is commonly known as \ac{FFI}.  It allows for the repurposing of
mature software libraries in foreign languages without the need for a complete
rewrite or adaptation.\footnote{The decision to include such a mechanism at the
language's core by the language designers makes it so the language can rapidly
evolve by avoiding reimplementing several facilities and software libraries in,
but not limited to, scientific and numerical computing areas.  Arguably, it may
be one of \textit{the} fundamental features that made the language as popular as
it is and kept it afloat, unlike other similar historical examples that might've
lacked such a mechanism.} This mechanism can also in turn be leveraged and built
upon to interface with other programming languages, e.g., Java, Python, MATLAB,
and, the one needed for our particular use-case, C++.\footnote{There is an
entire GitHub organization with projects dedicated to foreign language
interoperation at \url{https://github.com/JuliaInterop} (July 8, 2021)}

Overcoming the language interoperability hurdle, we can now start focusing on
the implementation of the \textit{Geometric Constraint Primitives}.  These
primitives build on top of the functionality available in \ac{CGAL}, some of
which is directly inherited from it, substantially helping us in the process,
e.g., intersections.  We further enriched the pool with a few more functions,
illustrating a constructive approach to \ac{GCS}, similar and inspired by the
approach of \textit{tkz-euclide} mentioned in
\cref{sec:related.constraints.tikz}.  By providing this abstraction over more
primitive functionality, we aimed to provide an easy to understand and utilize
set of tools so users can avoid reimplementing it themselves, which is an
error-prone process.  as levelling the playing field by working at a
conceptual level which is more familiar to and understood by traditional
\ac{CAD} software users rather than falling back to the more analytic approach
programming languages naturally offer.

The following sections will elaborate further on the components emphasized in
the previous paragraphs, adopting a bottom-up-like approach.  We'll discuss
\ac{CGAL} and what constructs and functionality it can provide to aid our goal,
as well as some added benefits of building on top of a very mature and
comprehensive library.  That will be followed by a section detailing how it was
possible to map said functionality to the Julia language, of which the result
was a Julia package aptly named \texttt{CGAL.jl}\footnote{Packages in the Julia
ecosystem are conventionally terminated with a \texttt{.jl} suffix, the
extension used for Julia files.  This is reminiscent of a familiar convention
followed in the Java ecosystem where libraries and tools are usually prefixed
with the letter \texttt{J}, e.g., \texttt{JUnit}, \texttt{JMeter},
\texttt{JDeveloper}, among others.}~\cite{Ventura:2019:CGAL.jl}.  Finally, we
showcase how we leveraged \texttt{CGAL.jl} to build the aforementioned
\textit{Geometric Constraint Primitives}, a set of functionality that implements
specialized yet comprehensible constructive approach solutions to \ac{GC}
problems.

\subsection{Exact Computation Geometric Library}%
\label{sec:solution.impl.cgal}
\todo[inline]{Introduce CGAL to the masses.  Showcase example program using
basic CGAL constructs and functionality.  Not sure where to put notes about the
library's complexity, but maybe include explanation of why it made sense to
choose CGAL as our library of choice (mature library, tons of research resulting
from several PhDs, open source $\implies$ open to contributions, lots of
contributors, active development, \textit{et cetera}).}

\begin{listing}[htb]
  \inputminted{cpp}{cpp/points_and_segments.cpp}
  \caption[CGAL: Three points and one segment]{
    An example CGAL program illustrating how to construct some points and a line
    segment, and perform some basic operations on them.  It uses \texttt{double}
    precision floating point numbers for cartesian coordinates.
  }
  \label{lst:solution.impl.cgal.pas}
\end{listing}

\subsection{Wrapper Code}%
\label{sec:solution.impl.jlcgal}
\todo[inline]{Reiterate the language interoperability hurdle, maybe mention
briefly there are complications especially when memory management models differ.
Showcase Julia's native capabilities of invoking native C++ libraries coupled w/
an example using CGAL.  Introduce a library that helps with C++ wrapping and
showcase a slightly more complex example, maybe involving classes and the like.
Consider demonstrating the ease with which it is possible to wrap things
incrementally as, on demand, requests for new features may require algorithms
from the library that weren't wrapped.  Just like following a recipe, it's
as simple as (1) looking at the docs, (2) mapping necessary types and functions,
and (3) run Julia (Carefully not mapping \textit{everything}, thought that is
what I strived to do with CGAL.jl, but that's another discussion).}

\begin{listing}[htb]
  \inputminted{cpp}{cpp/sqdist.cpp}
  \caption[C wrapper for squared distance functionality]{
    Example C library code that wraps \ac{CGAL}'s \texttt{squared\_distance}
    global function.  The original function takes in instances of
    \texttt{Point\_3} classes so we instantiate them from our \texttt{double}
    coordinate inputs.}
  \label{lst:solution.impl.jlcgal.sqdist.cpp}
\end{listing}

\begin{listing}[htb]
  \inputminted{julia}{jl/sqdist.jl}
  \caption[Julia squared distance example program]{
    Example Julia program that invokes the functionality from the library whose
    source is listed in \cref{lst:solution.impl.jlcgal.sqdist.cpp}.  Julia's
    \texttt{ccall} construct converts the input arguments' types to the types
    specified in the native C function's parameter types.}
  \label{lst:solution.impl.jlcgal.sqdist.jl}
\end{listing}

\begin{listing}[htb]
  \inputminted{cpp}{cpp/circ.cpp}
  \caption[C wrapper for circumcenter functionality]{
    Example C shared library source code that wraps \ac{CGAL}'s circumcenter
    global function.  In this instance, we use an additional struct to wrap
    around \ac{CGAL}'s \texttt{Point\_3} class to facilitate data transfer.}
  \label{lst:solution.impl.jlcgal.circ.cpp}
\end{listing}

\begin{listing}[htb]
  \inputminted{julia}{jl/circ.jl}
  \caption[Julia circumcenter example program]{
    Example Julia program that invokes the functionality from the library listed
    in \cref{lst:solution.impl.jlcgal.circ.cpp}.  We use an additional Julia
    struct that's equivalent to the one specified in C to facilitate data
    transfer.}
  \label{lst:solution.impl.jlcgal.circ.jl}
\end{listing}

\begin{listing}[htb]
  \inputminted{julia}{jl/points_and_segments.jl}
  \caption[CGAL.jl: Three points and one segment]{
    The example program as seen in \cref{lst:solution.impl.cgal.pas} written in
    the Julia programming language using \texttt{CGAL.jl}.  The kernel
    instantiation is hidden away in the C++ layer of the wrapper code.}
  \label{lst:solution.impl.jlcgal.pas}
\end{listing}

\subsection{Geometric Constraint Primitives}%
\label{sec:solution.impl.gcps}
\todo[inline]{With functionality available on the Julia side of things, call
back to the previously formulated examples, potentially elaborating with yet
another slightly more complex example.  Showcase that some of the functionality
that can be implemented with very little effort relying only on functionality
already present in mature library alone like CGAL is.  I confess I do not know
what to discuss in this section, despite feeling like it is the most important
one in some regard\ldots}

\begin{listing}[htb]
  \inputminted[highlightlines={5,19}]{julia}{jl/ex-parallel.jl}
  \caption[Parallel lines example using our solution]{
    Implementation of the parallel lines example illustrated in
    \cref{fig:intro.example.parallel} using Khepri alongside our solution
    backed by \texttt{CGAL.jl}.}
  \label{lst:solution.impl.gcps.parallel}
\end{listing}

\begin{listing}[htb]
  \inputminted[highlightlines={2,19}]{julia}{jl/ex-circumcenter.jl}
  \caption[Circumcenter example using our solution]{
    Implementation of the circumcenter example illustrated in
    \cref{fig:intro.example.circumcenter} using Khepri alongside our solution
    backed by \texttt{CGAL.jl}.  In this particular case, we can leverage
    \ac{CGAL}'s facilities directly.}
  \label{lst:solution.impl.gcps.circumcenter}
\end{listing}
