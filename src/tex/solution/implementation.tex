% !TEX root = ../../main.tex
\section{Implementation}%
\label{sec:solution.impl}

This section details implementation choices with regard to the chosen platforms
for realizing the initially proposed general solution architecture, previously
illustrated in \cref{fig:solution.arch}. Following a brief analysis, we expand
specifically on the concrete components corresponding to the ones within the
light blue rectangle.

Examining the \ac{AD} workflow portion of \cref{fig:solution.arch}, there are
depictions of \ac{CAD}, \ac{BIM}, and analysis tools, of which examples could be
Rhinoceros3D, Autodesk's Revit, and Radiance, respectively, with no particular
focus on any of them.  Digging a layer deeper, we find the \ac{AD} tool, which,
by means made available by the tools above it, produces models specific to those
tools from a description provided by the user.  The \ac{AD} tool we've chosen
was Khepri~\cite{Leitao:2019:GRUGEAV}, a text-based tool written in the Julia
programming language~\cite{Bezanson:2017:JAFANC}.  Khepri is the successor of
another text-based \ac{AD} tool named Rosetta~\cite{Leitao:2011:PGDCAD}, a tool
written in the Racket programming language~\cite{PLT:2010:Reference}.  It
follows that the \textit{Geometric Constraint Primitives} were implemented in
the Julia language as well, supported by an \textit{Exact Computation Geometry
Library}.  The library chosen for the effect was the
\acf{CGAL}~\cite{CGAL:2018}, a highly performant and robust geometric library
written in the C++ programming language~\cite{Stroustrup:2013:CPP}.

This language disparity between the \textit{Geometric Constraint Primitives}
module and the \textit{Exact Computation Geometry Library} requires a solution
for language interoperation.  In other words, we need to make \ac{CGAL}
available to the Julia language.  Fortunately, the Julia language already
possesses facilities that allow it to invoke functionality within libraries
written in the C~\cite{Kernighan:1988:C} or the
Fortran~\cite{Backus:1957:Fortran} programming languages.  This interfacing
mechanism is commonly known as \ac{FFI}.  It allows for the repurposing of
mature software libraries in foreign languages without the need for a complete
rewrite or adaptation.\footnote{The decision to include such a mechanism at the
language's core by the language designers makes it so the language can rapidly
evolve by avoiding reimplementing several facilities and software libraries in,
but not limited to, scientific and numerical computing areas.  Arguably, it may
be one of \textit{the} fundamental features that made the language as popular as
it is and kept it afloat, unlike other similar historical examples that might've
lacked such a mechanism.  \todo[inline]{Maybe expand on this with a concrete
example or so.  Could also be removed altogether}} This mechanism can also in
turn be leveraged and built upon to interface with other programming languages,
e.g., Java, Python, MATLAB, and, the one needed for our particular use-case,
C++.\footnote{There is an entire GitHub organization with projects dedicated to
foreign language interoperation at \url{https://github.com/JuliaInterop} (July
8, 2021)}

Overcoming the language interoperability hurdle, we can now start focusing on
the implementation of the \textit{Geometric Constraint Primitives}.
\todo[inline]{Elaborate a little bit more. Consider referring examples in
related work}

Adopting a bottom-up approach, we'll start by describing the underlying 
\textit{Exact Computation Geometry Library}, followed by the \textit{Wrapper
Code} layer, topped off by the \textit{Geometric Constraint Primitives} block.
The reason a wrapper code layer exists 
