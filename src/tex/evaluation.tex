% !TEX root = ../main.tex
\fancychapter{Evaluation}%
\label{chap:eval}
\cleardoublepage{}

\noindent In this chapter, we evaluate our solution by measuring the qualities
of the approach we took to tackle \ac{GCS}.

Firstly, we aim to benchmark our solution's performance by comparing it to a
similar project called ConstraintGM~\cite{Pinheiro:2016:MGR}.  We were able to
reproduce the project's original benchmark tests and create an analogous test
suite for our solution so we can compare both projects.

Secondly, we explore our approach's potential regarding repurposing more complex
geometric algorithms with intrinsic \ac{GC} relations in contrast with
re-implementing a version of said algorithms from scratch.  Specifically, we set
out to repurpose \ac{CGAL}'s 2D Delaunay Triangulation and Voronoi Diagram
algorithms and further compare the resulting mapping's performance and
correctness when compared to a native Julia implementation of the algorithms as
provided by the package
\texttt{VoronoiDelaunay.jl}\footnote{\url{https://github.com/JuliaGeometry/VoronoiDelaunay.jl}},
that, in the past, was once benchmarked against
\ac{CGAL}\footnote{\url{https://gist.github.com/skariel/3d2018f9341a058e00fc}}.
Additionally, we set out to estimate the effort it took to develop
\texttt{VoronoiDelaunay.jl} and compare that to the effort it took to extract an
analogous algorithm from \ac{CGAL}.

Finally, we end our evaluation by showcasing four different case studies
inspired by existing designs.  This section of the evaluation focuses on
comparing different approaches to solving \ac{GC} problems present in each case
study by adopting two different approaches: 
\begin{enumerate*}[label= (\arabic*)]
  \item an analytic approach, one programming naturally begs for, and 
  \item a constructive approach, essentially adding a conceptual abstraction
  layer over the former.
\end{enumerate*}
We aim to show that, by following the latter approach, resulting programs become
both easier to understand and reproducible as the set of instructions can be
used to recreate the resulting geometry by hand, using a ruler and a compass.

Benchmarks were performed on a Lenovo{\textregistered}
ThinkPad{\textregistered} E595 laptop computer with the following
system specifications:

\begin{itemize}
  \item \acsu{AMD}\label{acro:AMD} Ryzen\textsuperscript{\texttrademark} 5 3500U
  \acsu{CPU}\label{acro:CPU} @ 2.1GHz\footnote{Base clock frequency.  Can boost
  up to 3.7GHz.};
  \item 1Ã—16GB \acsu{SO-DIMM}\label{acro:SO-DIMM} of \acsu{DDR}\label{acro:DDR}4
  \acsu{RAM}\label{acro:RAM} @ 2400MT/s.
  \item Arch
  Linux\textsuperscript{\texttrademark}\footnote{\url{https://archlinux.org}}
  x86 64-bit, Linux{\textregistered} Kernel
  5.12.15-zen1\footnote{\url{https://github.com/zen-kernel/zen-kernel/tree/v5.12.15-zen1}}
\end{itemize}
\clearpage

\input{tex/evaluation/constraint-gm}

\section{VoronoiDelaunay.jl}%
\label{sec:eval.vdjl}

% \todo[inline]{Maybe leave the "how easy it is to leverage our approach to get
% more, both in quantity and complexity, algorithsm from CGAL" discussion for this
% part and evaluate the potential time it takes to use Voronoi Diagrams from CGAL
% and either get more information on how long it took to implement
% VoronoiDelaunay.jl and compare its "correctness" vs. CGAL's version of the
% algorithm, assuming CGAL's results as a source of truth for correctness.
% Testing revealed diagrams differed slightly when it came to some edges.  My
% suspicion was the Julia algorithm "gobble" some very very very small triangles,
% i.e., where the edges are very close together, but it only happens near the
% outside of the diagram, and, again, a more drastic diagram can be manufactured
% to showcase this.  Maybe read up more on the underlying algorithm that was
% implemented in VoronoiDelaunay.jl}

\input{tex/evaluation/case-studies}
