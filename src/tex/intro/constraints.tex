% !TEX root = ../../main.tex
\subsection{Constraints in CAD}%
\label{sec:intro.constraints}

Parametric operations allow the user to create geometric objects that satisfy
certain constraints \emph{implicitly} imposed on the objects when the user
selects the operation they want.  \Acp{GC}, on the other hand, allow the
repositioning and scaling of objects so that they satisfy constraints the user
\emph{explicitly} imposed on them.

The abstract problem of \ac{GCS} consists of assigning coordinates to
constrained geometric objects such that the constraints they are subject to are
satisfied.  Otherwise, the solver should report no such assignment can be found.

One of the important features of a solver is its \emph{competence}, which is
related to the capability of reporting unsolvability: if no solution for the
problem exists and the solver is capable of reporting unsolvability, the solver
is deemed fully competent.  Since constraint solving is mostly an exponentially
complex problem~\cite{Rossi:2006:Handbook}, partial competence suffices as long
as decent solutions can be found in affordable time and space.

In the context of \ac{GCS}, it is also important that the \ac{GC} system does
not have too few or too many constraints.  Summarily, a system can either be 
\begin{enumerate*}[label= (\arabic*)]
  \item under-constrained, if the number of solutions is unbound due to lack of
  constraint coverage;
  \item over-constrained, if there are no solutions because of contradictions;
  or
  \item well-constrained, if the number of solutions is finite.
\end{enumerate*}

Some of the subjects approached here are briefed in~\cite{Hoffmann:2005:BCS}.
The following sections present and briefly discuss the most relevant approaches
to constraint solving.

\subsubsection{Graph-Based Approaches}%
\label{sec:intro.constraints.graph}

The problem is translated into a labeled \textit{constraint graph}, where
vertices are constrained geometric objects, and edges the constraints
themselves.  These became the dominant \ac{GCS} approaches.

\subsubsection{Logic-Based Approaches}%
\label{sec:intro.constraints.logic}

The constraint problem is translated into a set of geometric assertions and
axioms which is then transformed in such a way that specific solution steps are
made explicit by applying geometric reasoning.  The solver then takes a set of
construction steps and assigns coordinate values to the geometric entities.

\subsubsection{Algebraic Approaches}%
\label{sec:intro.constraints.algebraic}

The problem is translated into a system of equations, which is generally
nonlinear.  This approach's main advantage is its completeness and dimension
independence.  However, it is difficult to decompose the equation system into
subproblems, and a general, complete solution of algebraic equations is
inefficient.  Nonetheless, small algebraic systems tend to appear in the other
approaches and are routinely solved.

\subsubsection{Symbolic Methods}%
\label{sec:intro.constraints.symbolic}

Symbolic methods rely on general equation solvers that employ techniques to
triangularize equation systems~\cite{Chou:1988:IWMMTPG,Buchberger:1995:Grobner}
that emerge from employing an algebraic approach.  These methods can produce
generic solutions, but solvers are very slow and computation demands a lot of
space, usually requiring exponential running time~\cite{Durand:1998:SNTCS}.

\subsubsection{Numerical Methods}%
\label{sec:intro.constraints.numerical}

Among the oldest approaches to constraint solving, numerical methods solve large
systems of equations iteratively.  Methods like Newton iteration work properly
if a good approximation of the intended solution can be supplied and the system
is not ill-conditioned.  Alas, such methods may find only one solution, even in
cases where there are many, and may not allow the user to select the one they
are interested in.

\subsubsection{Theorem Proving}%
\label{sec:intro.constraints.proving}

\ac{GCS} can be seen as a subproblem of geometric theorem proving, but the
latter requires general techniques, therefore requiring much more complex
methods than those required by the former.
